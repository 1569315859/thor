他们的确是有复制的
但是并没有在主和副本服务之间复制每一个bit的内存
但是并没有在主和副本服务之间复制每一个bit的内存
而是复制偏应用程序级别的内存块表
我对块和块标识符进行了这种抽象
这就是需要复制的东西
并不需要复制任何其他的东西
也没有在该机器上复制任何其他的东西的代价
也没有在该机器上复制任何其他的东西的代价
这样做是可以的
只要主服务和副本服务具有相同应用程序可见性的内存块集
因此大多数复制方案都采用与GFS相似的方案
实际上，几乎是除了这篇论文以及一些类似的系统之外的所有方案
实际上，几乎是除了这篇论文以及一些类似的系统之外的所有方案
他们几乎都使用了应用级别的复制
因为这样可以更有效率
因为我们不必费力的去确保
在主和副本服务运行时
中断发生在完全相同的时间点
GFS完全不用担心这点
但是本文必须要确保这点
因为它在很低的级别进行复制
因此大多数人使用特定于应用程序的复制来构建高效的系统
这样做的后果是
必须将复制内置到应用程序权限中
例如，如果你需要获取应用程序级别操作的提要
你就需要让应用程序参与其中
因为有些通用的复制方案，例如今天的论文
并不能理解哪些东西需要被复制的语义
因此大多数方案是针对于特定应用的
例如GFS以及我们将要在这个主题下阅读的所有其他论文
今天的论文的不同之处在于它实在机器级别进行复制的
因此它不关系在其上运行了什么软件
它复制低级别的内存以及寄存器
你可以其上运行任何软件
只要它可以在这种所表示的微处理器上运行
这种复制方案可以适应任何软件
缺点是效率不一定高
优点是你可以使用任何现有的软件
甚至你没有源代码或者不知道它是如何工作的
在一定的限制下，你就可以在VMware的复制方案下运行它
它可以正常工作，对于任意软件都可以进行容错
现在我们来讨论VMware FT
首先，VMware是一家虚拟机公司
他们的很多业务都在销售虚拟机技术
虚拟机指的是
你买一台电脑
在硬件上不是启动像Linux这样的操作系统
而是启动虚拟机监视器
它的工作实际上是
在此硬件上模拟多台虚拟的电脑
因此虚拟机监视器可能会启动一个Linux实例
多个Linux实例，或者一个Windows实例
这台计算机上的虚拟机监视器可以运行许多不同的操作系统
这台计算机上的虚拟机监视器可以运行许多不同的操作系统
它们每个包含某种操作系统内核以及应用程序
所以这是他们开始使用的技术
原因是事实证明
在硬件和操作系统之间进行这种级别的间接干预非常方便 的原因有很多
在硬件和操作系统之间进行这种级别的间接干预非常方便 的原因有很多
这意味着我们可以购买一台计算机
并在其上运行许多不同的操作系统
如果我们运行大量的小型服务
而不是使用大量的每台运行一个服务的计算机
你可以只购买一台计算机，在基于虚拟机上的操作系统中运行每个服务
你可以只购买一台计算机，在基于虚拟机上的操作系统中运行每个服务
这就是他们的出发点
在最开始设计VMware FT时，他们已经构建了这项功能和许多其他复杂的东西
在最开始设计VMware FT时，他们已经构建了这项功能和许多其他复杂的东西
所以这就是虚拟机
论文要做的是要搭建一台机器
或者说他们需要两台物理机
因为在同一台物理计算机上的不同虚拟机中运行主软件和副本软件毫无意义
因为在同一台物理计算机上的不同虚拟机中运行主软件和副本软件毫无意义
因为我们正在努力应对硬件故障
因此，你有两台计算机分别运行其虚拟机监视器
而主虚拟机将在一台计算机上运行，而副本虚拟机将在另一台上运行
在其中一台计算机上有一个guest操作系统...
它可能正在运行许多虚拟机
我们只在乎其中的一个
它会运行多个guest操作系统和服务应用程序
也许是数据库服务，MapReduce主数据库或其他东西
我们称这个为主虚拟机
这里有第二台计算机运行相同的虚拟机监视器
也有运行副本服务的相同的虚拟机
因此，无论是何种操作系统，我们都具有完全相同的东西
虚拟机为这些guest操作系统、主和副本服务器提供一定范围的内存空间
并且这两个内存镜像是完全相同的
或其目标是使它们在主和副本虚拟机中完全相同
我们有两台物理计算机
每台都在运行guest虚拟机
该虚拟机上带有我们关心的服务的副本
我们假设有一个网络连接了这两台机器
此外，在此局域网上还有一些客户端
事实上，它们不一定是是客户端
它们可能是带有复制的服务需要与之通信的其他计算机
其中一些是来发送请求的客户端
这篇论文中的带有复制的服务实际上并不使用本地磁盘
而是假设与某种磁盘服务器进行通信
尽管从本篇论文中很难意识到这一点
该方案实际上并没有特殊对待这种服务器
它只是数据包的另一个外部来源
只是复制状态机可能会将数据包发送到的地方
这与其他客户端没有太大不同
因此，基本方案是，我们假设
这两个副本、两个虚拟机、或者说主和副本虚拟机，都是精确的副本
某个客户端，例如数据库客户端
复制服务器的某个客户端向主虚拟机发送请求
而这实际上是以网络数据包的形式发送的，就是我们刚刚讨论的
而这实际上是以网络数据包的形式发送的，就是我们刚刚讨论的
它生成一个中断
该中断进入第一个实例的虚拟机监视器
虚拟机监视器发现复制服务的输入到来了
因此，虚拟机监视器会做两件事
第一件事，它模拟网络数据包到达中断，传递给主guest操作系统
第一件事，它模拟网络数据包到达中断，传递给主guest操作系统
以此将其传递给应用程序的主副本
第二件事，虚拟机监视器知道这是复制虚拟机的输入
第二件事，虚拟机监视器知道这是复制虚拟机的输入
因此，它通过网络将数据包副本发送给副本虚拟机监视器
因此，它通过网络将数据包副本发送给副本虚拟机监视器
所以它也得到了数据包，副本虚拟机监视器
知道它是此复制状态机的数据包
它在副本虚拟机中也会构造网络数据包到达中断，并传送数据包
它在副本虚拟机中也会构造网络数据包到达中断，并传送数据包
所以现在主和副本虚拟机都有了数据包的一份副本
它们看到的这个数据包、这个相同的输入
通过考虑大量的细节，会以相同的方式处理并保持同步
当然，服务可能会回复客户
在主虚拟机上，服务将生成一个回复数据包
将其发送到虚拟机监视器所模拟的NIC上
然后，虚拟机监视器将在主计算机上看到该输出数据包
它们会将回复通过网络发送回客户端
由于副本在运行完全相同的指令序列
它也会生成一个回复数据包返回给客户端
在其模拟的NIC上发送该回复数据包
虚拟机监视器模拟了该网卡
虚拟机监视器知道这是副本虚拟机
而它只允许主虚拟机生成输出
因此，虚拟机监视器会丢弃回复数据包
所以他们两个都看到了输入，而只有主虚拟机产生了输出
就术语而言，这篇论文将这种输入事件流
以及之后要讨论的其他事件流，称为日志记录通道
