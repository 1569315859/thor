可能是应用程序级别的序列号，或者我不知道的
你会看到所有的这些
实际上你会在lab2和lab3中看到
基本上我讲过的所有内容的，例如这个输出规则
你将设计自己的复制状态机
是
对第一部分
场景是
primary发送答复
然后要么primary服务器发送关闭数据包
要么客户端在收到primary的答复后关闭TCP连接
所以现在在客户端，没有连接
但backup端有连接
所以现在backup
backup消耗了输入中的最后一个日志条目，（backup）变成在线状态
在这个时间点我们不负责复制任何内容
因为backup现在是在线状态，没有其他副本因为primary已死
因此，如果backup无法与primary步骤一致
其实也没什么问题
因为primary已死，我们不想和它步骤一致
好，现在考虑primary没有死，还活着
从backup的角度来看TCP连接尚未关闭，primary在这个TCP连接上产生一个输出
该数据包通过TCP连接到达客户端
从客户的角度来看已经不存在了
客户没有大惊小怪
它只是将数据包丢掉，好像什么都没发生，应用程序不会知道
客户可以发送一个重置
类似TCP错误或任何数据包
回到backup，backup就可以执行其他操作
但这没关系
因为我们没有产生分歧
因为没有primary可以分歧
你可以应付一个直接的重置，不管怎样
实际上它基本上会忽略它
现在backup已经上线了，没有（primary）了
就复制而言，我们不欠任何人任何东西
是的
好吧，你可以打赌，因为backup内存映像与primary映像相同
他们发送具有相同源TCP编号的数据包
他们都是一样的
他们发送每个比特位都相同的的数据包
在这一层，服务器没有IP地址
或出于我们的目的
backup虚拟机和primary虚拟机具有IP地址
但是物理计算机和vmm对网络是透明的
这不完全准确，但基本上是这样的
物理机中的虚拟机监视器
在网络上实际上没有自己的身份
你可以配置成那样，而不是
在自己的TCP堆栈中具有自己操作系统的虚拟机
它有IP地址和以太网地址，和其他所有内容
在backup和primary都完全相同
当它发送一个数据包
它把虚拟机的IP地址和以太网地址一起发送
根据我脑中的模型，这些比特只是简单地传递到局域网
这正是我们想要的
所以它会产生完全相同的数据包
和primary会产生数据包的一致
也许有些小诡计，我们
如果是，这些实际上是插入到以太网交换机中的
这些物理机器可能插入在以太网交换机的不同端口中
我们希望以太网交换机改变主意
这两台机器中的哪台传递复制的以太网地址的数据包
所以那里有一些有趣的事情
在大多数情况下，它们只是生成相同的数据包
我们只是把它们发送出去
好吧，我一直在讲的另一个小细节是
我一直假设primary失败或backup失败
那是fail-stop对吧
但这不是唯一的可能
必须处理的另一个非常普遍的情况是
如果两台计算机仍处于启动状态并且正在运行
但是网络上发生了一些有趣的事情
导致他们无法互相交谈
但仍然能够与一些客户端交谈
如果发生这种情况，如果prumary，backup无法互相通信
但他们仍然可以与客户交谈
他们都会以为另一个副本死了
我最好接管并开始上线
因此，现在我们有两台机器上线提供服务
现在你知道他们不再发送彼此的日志事件或任何其他信息
他们开始分歧
也许他们接受不同的客户输入，并且各自的状态变得不同
所以现在我们发生了脑裂灾难
如果我们让backup和primary生效
因为这是一个网络故障，而不是这些机器故障
这篇论文解决问题的方式
是通过寻求外部权威做出有关
允许哪个backup或primary上线的决定
所以
他们的存储实际上不在本地磁盘上
这几乎没关系
但它们的存储在某些外部磁盘服务器上
像完全独立的服务一样位于该服务器中
与磁盘无关
这个服务器碰巧在网络中提供这个test-and-set服务
这个服务器碰巧在网络中提供这个test-and-set服务
你可以发送test-and-set要求给它
它在内存维护一些标志
它会设置标志并返回原来的值
因此primary和backup都必须获得此test-and-set标志
这有点像锁
为了上线，他们可能同时发送test-and-set请求
给这个test-and-set服务器
第一个返回一个答复，说哦，标志曾经是零
现在是第二个请求到达
test-and-set服务器的响应是
哦，实际上，当你的请求到达时，该标志已经是1
所以你不允许成为primary
所以这个test-and-set服务器
我们可以将其视为一台机器
是决定两者中哪一个应该生效的仲裁员
如果他们俩都认为其他人由于网络分区而死亡的话
有关此机制的任何问题
你被淘汰了
是的，如果test-and-set服务器在这个关键时刻死了
实际上即使没有网络分区
在任何情况下
其中一个希望上线，因为它认为其他人死了
即使对方真的死了
想要上线的那个也必须获得test-and-set锁
因为像6.824游戏的深层规则之一是
你无法判断另一台计算机是否坏掉了
你所知道的是，你不再能接收到数据包
而且你不知道是因为另一台计算机已死
还是由于你和另一台计算机之间的网络出了点问题
所以所有backup都停止，我被卡在数据包中
也许primary已经死了，也许还活着
primary可能看到相同的东西
所以如果有网络分区
他们一定要问test-and-set服务器
但由于他们不知道这是否是网络分区
他们必须询问test-and-set服务器，不管它是否是分区
所以任何时候都想上线
test-and-set服务器也必须处于在线状态
因为他们总是必须获得此test-and-set锁
因此test-and-set服务器听起来像是单点故障
他们试图建立一个复制的容错的东西
但最后你知道我们无法进行故障转移，除非它仍然活着
这有点令人烦恼
我猜
我强烈猜测test-and-set服务器实际上是
本身是有复制的服务，是具有容错性的
几乎可以肯定，我是说，VMware的这些人
他们很高兴向你出售百万美元的高可用性存储系统
在内部使用大量复制
嗯，因为test-and-set的东西在他们的这个服务器上
我在猜它也被复制了
你在lab2中和lab3中做的事情足够强大
你可以用它构建自己的容错的test-and-set服务器
所以这个问题很容易消除
